diff --git a/c/blake3_avx2.c b/c/blake3_avx2.c
index e76aa1a..f83bb41 100644
--- a/c/blake3_avx2.c
+++ b/c/blake3_avx2.c
@@ -220,7 +220,7 @@ INLINE void load_counters(uint64_t counter, bool increment_counter,
   const __m256i add0 = _mm256_set_epi32(7, 6, 5, 4, 3, 2, 1, 0);
   const __m256i add1 = _mm256_and_si256(mask, add0);
   __m256i l = _mm256_add_epi32(_mm256_set1_epi32((int32_t)counter), add1);
-  __m256i carry = _mm256_cmpgt_epi32(_mm256_xor_si256(add1, _mm256_set1_epi32(0x80000000)), 
+  __m256i carry = _mm256_cmpgt_epi32(_mm256_xor_si256(add1, _mm256_set1_epi32(0x80000000)),
                                      _mm256_xor_si256(   l, _mm256_set1_epi32(0x80000000)));
   __m256i h = _mm256_sub_epi32(_mm256_set1_epi32((int32_t)(counter >> 32)), carry);
   *out_lo = l;
diff --git a/c/blake3_dispatch.c b/c/blake3_dispatch.c
index 95213db..43ee59e 100644
--- a/c/blake3_dispatch.c
+++ b/c/blake3_dispatch.c
@@ -4,10 +4,10 @@
 
 #include "blake3_impl.h"
 
-#if defined(IS_X86)
+#if defined(IS_X86) || defined(IS_WASM)
 #if defined(_MSC_VER)
 #include <intrin.h>
-#elif defined(__GNUC__)
+#elif defined(__GNUC__) || defined(IS_WASM)
 #include <immintrin.h>
 #else
 #error "Unimplemented!"
@@ -126,6 +126,8 @@ static
     }
     g_cpu_features = features;
     return features;
+#elif defined(IS_WASM)
+  return SSE2 | SSSE3 | AVX | SSE41;
 #else
     /* How to detect NEON? */
     return 0;
@@ -137,7 +139,7 @@ void blake3_compress_in_place(uint32_t cv[8],
                               const uint8_t block[BLAKE3_BLOCK_LEN],
                               uint8_t block_len, uint64_t counter,
                               uint8_t flags) {
-#if defined(IS_X86)
+#if defined(IS_X86) || defined(IS_WASM)
   const enum cpu_feature features = get_cpu_features();
   MAYBE_UNUSED(features);
 #if !defined(BLAKE3_NO_AVX512)
@@ -166,7 +168,7 @@ void blake3_compress_xof(const uint32_t cv[8],
                          const uint8_t block[BLAKE3_BLOCK_LEN],
                          uint8_t block_len, uint64_t counter, uint8_t flags,
                          uint8_t out[64]) {
-#if defined(IS_X86)
+#if defined(IS_X86) || defined(IS_WASM)
   const enum cpu_feature features = get_cpu_features();
   MAYBE_UNUSED(features);
 #if !defined(BLAKE3_NO_AVX512)
@@ -195,7 +197,7 @@ void blake3_hash_many(const uint8_t *const *inputs, size_t num_inputs,
                       size_t blocks, const uint32_t key[8], uint64_t counter,
                       bool increment_counter, uint8_t flags,
                       uint8_t flags_start, uint8_t flags_end, uint8_t *out) {
-#if defined(IS_X86)
+#if defined(IS_X86) || defined(IS_WASM)
   const enum cpu_feature features = get_cpu_features();
   MAYBE_UNUSED(features);
 #if !defined(BLAKE3_NO_AVX512)
@@ -245,7 +247,7 @@ void blake3_hash_many(const uint8_t *const *inputs, size_t num_inputs,
 
 // The dynamically detected SIMD degree of the current platform.
 size_t blake3_simd_degree(void) {
-#if defined(IS_X86)
+#if defined(IS_X86) || defined(IS_WASM)
   const enum cpu_feature features = get_cpu_features();
   MAYBE_UNUSED(features);
 #if !defined(BLAKE3_NO_AVX512)
diff --git a/c/blake3_impl.h b/c/blake3_impl.h
index cc5672f..7157272 100644
--- a/c/blake3_impl.h
+++ b/c/blake3_impl.h
@@ -28,7 +28,7 @@ enum blake3_flags {
 #define INLINE static inline __attribute__((always_inline))
 #endif
 
-#if defined(__x86_64__) || defined(_M_X64) 
+#if defined(__x86_64__) || defined(_M_X64)
 #define IS_X86
 #define IS_X86_64
 #endif
@@ -42,14 +42,14 @@ enum blake3_flags {
 #define IS_AARCH64
 #endif
 
-#if defined(IS_X86)
+#if defined(IS_X86) || defined(IS_WASM)
 #if defined(_MSC_VER)
 #include <intrin.h>
 #endif
 #include <immintrin.h>
 #endif
 
-#if !defined(BLAKE3_USE_NEON) 
+#if !defined(BLAKE3_USE_NEON)
   // If BLAKE3_USE_NEON not manually set, autodetect based on AArch64ness
   #if defined(IS_AARCH64)
     #define BLAKE3_USE_NEON 1
@@ -58,7 +58,7 @@ enum blake3_flags {
   #endif
 #endif
 
-#if defined(IS_X86)
+#if defined(IS_X86) || defined(IS_WASM)
 #define MAX_SIMD_DEGREE 16
 #elif BLAKE3_USE_NEON == 1
 #define MAX_SIMD_DEGREE 4
@@ -130,7 +130,7 @@ INLINE unsigned int popcnt(uint64_t x) {
 }
 
 // Largest power of two less than or equal to x. As a special case, returns 1
-// when x is 0. 
+// when x is 0.
 INLINE uint64_t round_down_to_power_of_2(uint64_t x) {
   return 1ULL << highest_one(x | 1);
 }
@@ -213,7 +213,7 @@ void blake3_hash_many_portable(const uint8_t *const *inputs, size_t num_inputs,
                                uint8_t flags, uint8_t flags_start,
                                uint8_t flags_end, uint8_t *out);
 
-#if defined(IS_X86)
+#if defined(IS_X86) || defined(IS_WASM)
 #if !defined(BLAKE3_NO_SSE2)
 void blake3_compress_in_place_sse2(uint32_t cv[8],
                                    const uint8_t block[BLAKE3_BLOCK_LEN],
diff --git a/c/blake3_sse2.c b/c/blake3_sse2.c
index f4449ac..e818df3 100644
--- a/c/blake3_sse2.c
+++ b/c/blake3_sse2.c
@@ -449,7 +449,7 @@ INLINE void load_counters(uint64_t counter, bool increment_counter,
   const __m128i add0 = _mm_set_epi32(3, 2, 1, 0);
   const __m128i add1 = _mm_and_si128(mask, add0);
   __m128i l = _mm_add_epi32(_mm_set1_epi32((int32_t)counter), add1);
-  __m128i carry = _mm_cmpgt_epi32(_mm_xor_si128(add1, _mm_set1_epi32(0x80000000)), 
+  __m128i carry = _mm_cmpgt_epi32(_mm_xor_si128(add1, _mm_set1_epi32(0x80000000)),
                                   _mm_xor_si128(   l, _mm_set1_epi32(0x80000000)));
   __m128i h = _mm_sub_epi32(_mm_set1_epi32((int32_t)(counter >> 32)), carry);
   *out_lo = l;
